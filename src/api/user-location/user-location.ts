/**
 * Generated by orval v6.12.1 🍺
 * Do not edit manually.
 * Leg User API
 * OpenAPI spec version: 1.0.0
 */
import { useQuery, useInfiniteQuery, useMutation } from '@tanstack/react-query';
import type {
  UseQueryOptions,
  UseInfiniteQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction,
  UseQueryResult,
  UseInfiniteQueryResult,
  QueryKey,
} from '@tanstack/react-query';
import type { LocationDetail, AddLocationReq } from '.././types';
import { axiosInstance } from '../../../axios-instance';
import type { ErrorType } from '../../../axios-instance';

/**
 * @summary 유저 위치 목록 반환
 */
export const getLocationList = (signal?: AbortSignal) => {
  return axiosInstance<LocationDetail[]>({ url: `/locations`, method: 'get', signal });
};

export const getGetLocationListQueryKey = () => [`/locations`];

export type GetLocationListInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getLocationList>>>;
export type GetLocationListInfiniteQueryError = ErrorType<unknown>;

export const useGetLocationListInfinite = <
  TData = Awaited<ReturnType<typeof getLocationList>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof getLocationList>>, TError, TData>;
}): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLocationListQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLocationList>>> = ({ signal }) => getLocationList(signal);

  const query = useInfiniteQuery<Awaited<ReturnType<typeof getLocationList>>, TError, TData>({
    queryKey,
    queryFn,
    ...queryOptions,
  }) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export type GetLocationListQueryResult = NonNullable<Awaited<ReturnType<typeof getLocationList>>>;
export type GetLocationListQueryError = ErrorType<unknown>;

export const useGetLocationList = <
  TData = Awaited<ReturnType<typeof getLocationList>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getLocationList>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLocationListQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLocationList>>> = ({ signal }) => getLocationList(signal);

  const query = useQuery<Awaited<ReturnType<typeof getLocationList>>, TError, TData>({
    queryKey,
    queryFn,
    ...queryOptions,
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * 집, 회사 즐겨찾기의 경우 isMarked 를 true 로 하고, alias 를 HOME 또는 COMPANY 로 설정
 * @summary 유저 위치 추가
 */
export const addLocation = (addLocationReq: AddLocationReq) => {
  return axiosInstance<LocationDetail>({
    url: `/locations`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: addLocationReq,
  });
};

export type AddLocationMutationResult = NonNullable<Awaited<ReturnType<typeof addLocation>>>;
export type AddLocationMutationBody = AddLocationReq;
export type AddLocationMutationError = ErrorType<unknown>;

export const useAddLocation = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof addLocation>>, TError, { data: AddLocationReq }, TContext>;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof addLocation>>, { data: AddLocationReq }> = props => {
    const { data } = props ?? {};

    return addLocation(data);
  };

  return useMutation<Awaited<ReturnType<typeof addLocation>>, TError, { data: AddLocationReq }, TContext>(
    mutationFn,
    mutationOptions,
  );
};
/**
 * 유저의 위치 목록 중 1개 위치 활성화
 * @summary 유저 위치 활성화
 */
export const activeLocation = (locationId: number) => {
  return axiosInstance<LocationDetail>({ url: `/locations/${locationId}/active`, method: 'patch' });
};

export type ActiveLocationMutationResult = NonNullable<Awaited<ReturnType<typeof activeLocation>>>;

export type ActiveLocationMutationError = ErrorType<unknown>;

export const useActiveLocation = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof activeLocation>>, TError, { locationId: number }, TContext>;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof activeLocation>>, { locationId: number }> = props => {
    const { locationId } = props ?? {};

    return activeLocation(locationId);
  };

  return useMutation<Awaited<ReturnType<typeof activeLocation>>, TError, { locationId: number }, TContext>(
    mutationFn,
    mutationOptions,
  );
};
/**
 * 현재 유저의 설정 위치 반환
 * @summary 유저 활성화 위치 반환
 */
export const getActiveLocation = (signal?: AbortSignal) => {
  return axiosInstance<LocationDetail>({ url: `/locations/active`, method: 'get', signal });
};

export const getGetActiveLocationQueryKey = () => [`/locations/active`];

export type GetActiveLocationInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getActiveLocation>>>;
export type GetActiveLocationInfiniteQueryError = ErrorType<unknown>;

export const useGetActiveLocationInfinite = <
  TData = Awaited<ReturnType<typeof getActiveLocation>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActiveLocation>>, TError, TData>;
}): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetActiveLocationQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getActiveLocation>>> = ({ signal }) =>
    getActiveLocation(signal);

  const query = useInfiniteQuery<Awaited<ReturnType<typeof getActiveLocation>>, TError, TData>({
    queryKey,
    queryFn,
    ...queryOptions,
  }) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export type GetActiveLocationQueryResult = NonNullable<Awaited<ReturnType<typeof getActiveLocation>>>;
export type GetActiveLocationQueryError = ErrorType<unknown>;

export const useGetActiveLocation = <
  TData = Awaited<ReturnType<typeof getActiveLocation>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getActiveLocation>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetActiveLocationQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getActiveLocation>>> = ({ signal }) =>
    getActiveLocation(signal);

  const query = useQuery<Awaited<ReturnType<typeof getActiveLocation>>, TError, TData>({
    queryKey,
    queryFn,
    ...queryOptions,
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};
