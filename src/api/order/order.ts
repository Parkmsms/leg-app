/**
 * Generated by orval v6.12.1 🍺
 * Do not edit manually.
 * Leg User API
 * OpenAPI spec version: 1.0.0
 */
import { useQuery, useInfiniteQuery, useMutation } from '@tanstack/react-query';
import type {
  UseQueryOptions,
  UseInfiniteQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction,
  UseQueryResult,
  UseInfiniteQueryResult,
  QueryKey,
} from '@tanstack/react-query';
import type {
  OrderRespForPay,
  OrderCreateReq,
  OrderDoneResp,
  FinishOrderByUserParams,
  OrderSimple,
  CursorPointHistory,
  GetPointHistoryParams,
  CursorOrderListResp,
  GetOnOrdersByUserParams,
  GetOffOrdersByUserParams,
} from '.././types';
import { axiosInstance } from '../../../axios-instance';
import type { ErrorType } from '../../../axios-instance';

/**
 * @summary 주문 생성 (유저)
 */
export const createOrder = (orderCreateReq: OrderCreateReq) => {
  return axiosInstance<OrderRespForPay>({
    url: `/orders`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: orderCreateReq,
  });
};

export type CreateOrderMutationResult = NonNullable<Awaited<ReturnType<typeof createOrder>>>;
export type CreateOrderMutationBody = OrderCreateReq;
export type CreateOrderMutationError = ErrorType<unknown>;

export const useCreateOrder = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof createOrder>>, TError, { data: OrderCreateReq }, TContext>;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createOrder>>, { data: OrderCreateReq }> = props => {
    const { data } = props ?? {};

    return createOrder(data);
  };

  return useMutation<Awaited<ReturnType<typeof createOrder>>, TError, { data: OrderCreateReq }, TContext>(
    mutationFn,
    mutationOptions,
  );
};
/**
 * @summary 주문 완료 (유저)
 */
export const finishOrderByUser = (orderNo: string, params: FinishOrderByUserParams) => {
  return axiosInstance<OrderDoneResp>({ url: `/orders/${orderNo}/finish`, method: 'post', params });
};

export type FinishOrderByUserMutationResult = NonNullable<Awaited<ReturnType<typeof finishOrderByUser>>>;

export type FinishOrderByUserMutationError = ErrorType<unknown>;

export const useFinishOrderByUser = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof finishOrderByUser>>,
    TError,
    { orderNo: string; params: FinishOrderByUserParams },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof finishOrderByUser>>,
    { orderNo: string; params: FinishOrderByUserParams }
  > = props => {
    const { orderNo, params } = props ?? {};

    return finishOrderByUser(orderNo, params);
  };

  return useMutation<
    Awaited<ReturnType<typeof finishOrderByUser>>,
    TError,
    { orderNo: string; params: FinishOrderByUserParams },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * 주문이 아직 수락되지 않았거나, 픽업시간까지 남은 시간이 최소 조리시간보다 길다면 유저가 취소 가능
 * @summary 주문 취소 (유저)
 */
export const cancelOrder = (orderNo: string) => {
  return axiosInstance<boolean>({ url: `/orders/${orderNo}/cancel`, method: 'post' });
};

export type CancelOrderMutationResult = NonNullable<Awaited<ReturnType<typeof cancelOrder>>>;

export type CancelOrderMutationError = ErrorType<unknown>;

export const useCancelOrder = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof cancelOrder>>, TError, { orderNo: string }, TContext>;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof cancelOrder>>, { orderNo: string }> = props => {
    const { orderNo } = props ?? {};

    return cancelOrder(orderNo);
  };

  return useMutation<Awaited<ReturnType<typeof cancelOrder>>, TError, { orderNo: string }, TContext>(
    mutationFn,
    mutationOptions,
  );
};
/**
 * 주문 현황에 사용
 * @summary 주문 간단 정보 조회 (유저)
 */
export const getOrderSimple = (orderNo: string, signal?: AbortSignal) => {
  return axiosInstance<OrderSimple>({ url: `/orders/${orderNo}/simple`, method: 'get', signal });
};

export const getGetOrderSimpleQueryKey = (orderNo: string) => [`/orders/${orderNo}/simple`];

export type GetOrderSimpleInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderSimple>>>;
export type GetOrderSimpleInfiniteQueryError = ErrorType<unknown>;

export const useGetOrderSimpleInfinite = <
  TData = Awaited<ReturnType<typeof getOrderSimple>>,
  TError = ErrorType<unknown>,
>(
  orderNo: string,
  options?: { query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderSimple>>, TError, TData> },
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetOrderSimpleQueryKey(orderNo);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderSimple>>> = ({ signal }) =>
    getOrderSimple(orderNo, signal);

  const query = useInfiniteQuery<Awaited<ReturnType<typeof getOrderSimple>>, TError, TData>({
    queryKey,
    queryFn,
    enabled: !!orderNo,
    ...queryOptions,
  }) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export type GetOrderSimpleQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderSimple>>>;
export type GetOrderSimpleQueryError = ErrorType<unknown>;

export const useGetOrderSimple = <TData = Awaited<ReturnType<typeof getOrderSimple>>, TError = ErrorType<unknown>>(
  orderNo: string,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getOrderSimple>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetOrderSimpleQueryKey(orderNo);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderSimple>>> = ({ signal }) =>
    getOrderSimple(orderNo, signal);

  const query = useQuery<Awaited<ReturnType<typeof getOrderSimple>>, TError, TData>({
    queryKey,
    queryFn,
    enabled: !!orderNo,
    ...queryOptions,
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary 유저 포인트 적립,사용 내역 조회
 */
export const getPointHistory = (params?: GetPointHistoryParams, signal?: AbortSignal) => {
  return axiosInstance<CursorPointHistory>({ url: `/orders/points`, method: 'get', params, signal });
};

export const getGetPointHistoryQueryKey = (params?: GetPointHistoryParams) => [
  `/orders/points`,
  ...(params ? [params] : []),
];

export type GetPointHistoryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getPointHistory>>>;
export type GetPointHistoryInfiniteQueryError = ErrorType<unknown>;

export const useGetPointHistoryInfinite = <
  TData = Awaited<ReturnType<typeof getPointHistory>>,
  TError = ErrorType<unknown>,
>(
  params?: GetPointHistoryParams,
  options?: { query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPointHistory>>, TError, TData> },
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPointHistoryQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPointHistory>>> = ({ signal }) =>
    getPointHistory(params, signal);

  const query = useInfiniteQuery<Awaited<ReturnType<typeof getPointHistory>>, TError, TData>({
    queryKey,
    queryFn,
    ...queryOptions,
  }) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export type GetPointHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof getPointHistory>>>;
export type GetPointHistoryQueryError = ErrorType<unknown>;

export const useGetPointHistory = <TData = Awaited<ReturnType<typeof getPointHistory>>, TError = ErrorType<unknown>>(
  params?: GetPointHistoryParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getPointHistory>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPointHistoryQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPointHistory>>> = ({ signal }) =>
    getPointHistory(params, signal);

  const query = useQuery<Awaited<ReturnType<typeof getPointHistory>>, TError, TData>({
    queryKey,
    queryFn,
    ...queryOptions,
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary 진행중인 주문 리스트 반환 (유저)
 */
export const getOnOrdersByUser = (params?: GetOnOrdersByUserParams, signal?: AbortSignal) => {
  return axiosInstance<CursorOrderListResp>({ url: `/orders/on`, method: 'get', params, signal });
};

export const getGetOnOrdersByUserQueryKey = (params?: GetOnOrdersByUserParams) => [
  `/orders/on`,
  ...(params ? [params] : []),
];

export type GetOnOrdersByUserInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getOnOrdersByUser>>>;
export type GetOnOrdersByUserInfiniteQueryError = ErrorType<unknown>;

export const useGetOnOrdersByUserInfinite = <
  TData = Awaited<ReturnType<typeof getOnOrdersByUser>>,
  TError = ErrorType<unknown>,
>(
  params?: GetOnOrdersByUserParams,
  options?: { query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOnOrdersByUser>>, TError, TData> },
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetOnOrdersByUserQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOnOrdersByUser>>> = ({ signal }) =>
    getOnOrdersByUser(params, signal);

  const query = useInfiniteQuery<Awaited<ReturnType<typeof getOnOrdersByUser>>, TError, TData>({
    queryKey,
    queryFn,
    ...queryOptions,
  }) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export type GetOnOrdersByUserQueryResult = NonNullable<Awaited<ReturnType<typeof getOnOrdersByUser>>>;
export type GetOnOrdersByUserQueryError = ErrorType<unknown>;

export const useGetOnOrdersByUser = <
  TData = Awaited<ReturnType<typeof getOnOrdersByUser>>,
  TError = ErrorType<unknown>,
>(
  params?: GetOnOrdersByUserParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getOnOrdersByUser>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetOnOrdersByUserQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOnOrdersByUser>>> = ({ signal }) =>
    getOnOrdersByUser(params, signal);

  const query = useQuery<Awaited<ReturnType<typeof getOnOrdersByUser>>, TError, TData>({
    queryKey,
    queryFn,
    ...queryOptions,
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary 완료, 거절, 취소 주문 리스트 반환 (유저)
 */
export const getOffOrdersByUser = (params?: GetOffOrdersByUserParams, signal?: AbortSignal) => {
  return axiosInstance<CursorOrderListResp>({ url: `/orders/off`, method: 'get', params, signal });
};

export const getGetOffOrdersByUserQueryKey = (params?: GetOffOrdersByUserParams) => [
  `/orders/off`,
  ...(params ? [params] : []),
];

export type GetOffOrdersByUserInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getOffOrdersByUser>>>;
export type GetOffOrdersByUserInfiniteQueryError = ErrorType<unknown>;

export const useGetOffOrdersByUserInfinite = <
  TData = Awaited<ReturnType<typeof getOffOrdersByUser>>,
  TError = ErrorType<unknown>,
>(
  params?: GetOffOrdersByUserParams,
  options?: { query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOffOrdersByUser>>, TError, TData> },
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetOffOrdersByUserQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOffOrdersByUser>>> = ({ signal }) =>
    getOffOrdersByUser(params, signal);

  const query = useInfiniteQuery<Awaited<ReturnType<typeof getOffOrdersByUser>>, TError, TData>({
    queryKey,
    queryFn,
    ...queryOptions,
  }) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export type GetOffOrdersByUserQueryResult = NonNullable<Awaited<ReturnType<typeof getOffOrdersByUser>>>;
export type GetOffOrdersByUserQueryError = ErrorType<unknown>;

export const useGetOffOrdersByUser = <
  TData = Awaited<ReturnType<typeof getOffOrdersByUser>>,
  TError = ErrorType<unknown>,
>(
  params?: GetOffOrdersByUserParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getOffOrdersByUser>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetOffOrdersByUserQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOffOrdersByUser>>> = ({ signal }) =>
    getOffOrdersByUser(params, signal);

  const query = useQuery<Awaited<ReturnType<typeof getOffOrdersByUser>>, TError, TData>({
    queryKey,
    queryFn,
    ...queryOptions,
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};
